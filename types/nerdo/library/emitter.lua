---@meta
error("Do not try to execute this file. It's just a type definition file.")
---
---Part of the afseq trait: Defines LuaLS annotations for the afseq Emitter class.
---

----------------------------------------------------------------------------------------------------

---Context passed to `pattern` functions/generators.
---@class PatternContext
-----Transport playback running.
-----TODO: @field playing boolean
-----Project's tempo in beats per minutes.
---@field beats_per_min number
-----Project's beats per bar setting.
---@field beats_per_bar integer
-----Project's sample rate in samples per second.
---@field sample_rate integer
---
---Continues step counter, incrementing with each new emitted value. 
---Starts from 1 when the emitter starts running or is reset.
---@field step integer

----------------------------------------------------------------------------------------------------

---Context passed to 'emit' functions/generators.
---@class EmitterContext : PatternContext
---
---Current pulse's step time as fraction of a full step in the pattern. For simple pulses this
---will be 1, for pulses in subdivisions this will be the reciprocal of the number of steps in the
---subdivision, relative to the parent subdivisions pulse step time.
---### Example
---```lua
---{1, {1, 1}} --> step times: {1, {0.5, 0.5}}
---```
---@field step_time number
---Current pulse value. For binary pulses this will be 1, 0 pulse values will not cause the emitter
---to be called, so they never end up here.
---Values between 0 and 1 will be used as probabilities and thus are maybe emitted or skipped.
---@field step_value number
---Number of steps in the pattern, aka 'pattern_length'. When the pattern is a function or genenator
---this will only count the number of subdivisions in the currently emitted pulse. 
---@field step_count integer

----------------------------------------------------------------------------------------------------

---Single pulse value or a nested subdivion of pulses within a pattern.
---@alias Pulse (0|1|number|boolean|nil)|(Pulse)[]

----------------------------------------------------------------------------------------------------

---Construction options for a new emitter.
---@class EmitterOptions
---
---Base time unit of the emitter. Use `resolution` to apply an additional factor, in order to
---create other less common rhythm bases.
---### examples:
---```lua
---unit = "beats", resolution = 1.01 --> slightly off beat pulse
---unit = "1/16", resolution = 4/3 --> tripplet
---```
---@field unit "ms"|"seconds"|"bars"|"beats"|"1/1"|"1/2"|"1/4"|"1/8"|"1/16"|"1/32"|"1/64"
---Factor which is applied on `unit` to specify the final time resolution of the emitter.
---### examples:
---```lua
---unit = "beats", resolution = 1.01 --> slightly off beat pulse
---unit = "1/16", resolution = 4/3 --> tripplet
---```
---@field resolution number?
---
---Specify the rythmical pattern of the emitter. Each pulse with a value of 1 or true 
---will cause an event from the `emitter` property to be triggered in the emitters 
---time unit. 0 or nil values never trigger, and values inbetween do *maybe* trigger.
---
---To create deterministic random patterns, seed the random number generator before 
---creating the emitter via `math.randomseed(some_seed)` 
---
---Patterns can contains subdivisions, sub tables of pulses, to "cram" multiple pulses
---into a single pulse's time interval. This way more complex rhythmical patterns can
---be created.  
---
---When no pattern is defined, a constant pulse of `1` is triggered by the emitter.
---
---Patterns are repeated endlessly.
---
---Just like the `emitter` property, patterns can either be a fixed array of values or a
---function or generator which produce values dynamically.
---
---### examples:
---```lua
---pattern = { 1, 0, 0, 1 },
---pattern = pattern.from{ 1, 0 } * 3 + { 1, 1 }
---pattern = pattern.euclidean(7, 16, 2)
---
---pattern = { 1, 0, 0.5, 0.9 }, -- maybe trigger with probabilities
---
---pattern = {1, {1, 1, 1}} -- "cram" pulses via subdivisions
---
---pattern = function(_context)  -- dynamic function
---  return math.random(0, 1)
---end
---
---pattern = function (initial_context) --- dynamic generator
---  local pattern = table.create({0, 6, 10})
---  ---@param context EmitterContext
---  return function (context)
---    return pattern:find((context.step - 1) % 16) ~= nil
---  end
---end,
---```
---@field pattern Pulse[]|(fun(context: PatternContext):Pulse)|(fun(context: PatternContext):fun(context: PatternContext):Pulse)?
---
---Specify the melodic pattern of the emitter. For every pulse in the rhythmical pattern, the
---next event from the specified emit sequence gets triggered. When the end of the sequence is
---reached, it restarts from the beginning.<br>
---In order to dynamically generate notes, you can pass a function or a generator function, instead
---of a fixed note array or sequence.
---### examples:
---```lua
---emit = {"c4", "g4"}, -- a sequence of c4, g4
---emit = {{"c4", "g4"}}, -- a chord of c4, g4
---emit = sequence{"c4", "g4"}:with_volume(0.5), -- a sequence of c4, g4 with volume 0.5
---
---emit = function(context) -- a function
---  return 48 + math.random(1, 4) * 5
---end,
---
---emit = function(initial_context) -- a generator (function with upvalue state)
---  local count, step, notes = 1, 2, scale("c5", "minor").notes
---  ---@param context EmitterContext
---  return function(context)
---    local key = notes[count]
---    count = (count + step - 1) % #notes + 1
---    return { key = key, volume = 0.5 }
---  end
---end
---```
---@field emit Sequence|Note|NoteValue|(NoteValue|Note)[]|(fun(context: EmitterContext):NoteValue)|(fun(context: EmitterContext):fun(context: EmitterContext):NoteValue)


----------------------------------------------------------------------------------------------------

---Create a new emitter with the given options.
---
---### examples:
---```lua
----- trigger a chord sequence every 4 bars
---return emitter {
---  unit = "bars",
---  resolution = 4,
---  offset = 16,
---  emit = sequence("c4'm", note("g3'm7"):transpose({0, 12, 0, 0}))
---}
---
-----trigger c3 notes in an euclidean tripplet pattern
---local pattern = require "pattern"
---return emitter {
---  unit = "1/8",
---  resolution = 3/2,
---  pattern = pattern.euclidean(6, 16, 2),
---  emit = sequence("c7", "c7", note{ "c6", "a3" }:with_volume(0.5))
---}
---
-----trigger random notes in a random pattern from a pentatonic scale
---local pattern = require "pattern"
---local scale = scale("c5", "pentatonic minor").notes
---return emitter {
---  unit = "1/8",
---  pattern = function (context)
---    return math.random() > 0.7 or context.step % 4 == 1
---  end,
---  emit = function(context)
---    return { key = scale[math.random(#scale)] }
---  end
---}
---```
---@param options EmitterOptions
---@return userdata
function emitter(options) end
