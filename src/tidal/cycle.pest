//! pest parser grammar for mini-notations, based
//! on the TidalCycles mini-notation parser by Alex McLean.

// define whitespaces as space, tab, non-breaking space and newlines
WHITESPACE = _{ " " | "\t" | "\u{A0}" | NEWLINE }

/// numbers types allowing [ "1" "1.0" "1." ".1" ]
digit   = @{("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)}
integer = @{ "-"? ~ digit}
normal  = @{ "-"? ~ "." ~ digit }
float   = @{ "-"? ~ digit ~ "." ~ (digit)* }
// exp           = _{ ^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+ }
number  = ${ (normal | float | integer) ~ !(ASCII_ALPHA) }

/// case-incensitive pitch type with note, optional octave and sharp or flat mark
octave  = { "10" | ASCII_DIGIT }
mark    = { "#"|"b" }
note    = ${ (^"a"|^"b"|^"c"|^"d"|^"e"|^"f"|^"g") }
pitch   = ${ note ~ mark? ~ octave? ~ !(ASCII_ALPHANUMERIC)}

/// type for empty steps
rest = @{ ("~" | "-") ~ !(ASCII_ALPHANUMERIC) }

/// type for held steps
hold = @{ "_" ~ !(ASCII_ALPHANUMERIC) }

/// arbitrary string identifier type
name = @{ (ASCII_ALPHANUMERIC | "_")+ }

repeat = { "!" }

/// possible literals for single steps
single = { hold | rest | number | pitch | name }

/// groups
subdivision     = { "[" ~ (stack | choices | section)? ~ "]" }
alternating     = { "<" ~ (stack | section)? ~ ">" }

polymeter_count = { (ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* ~ !(ASCII_ALPHANUMERIC | "."))}
polymeter_tail  = { "%" ~  polymeter_count}
polymeter       = { "{" ~ (stack | section)? ~ "}" ~ polymeter_tail? }

group     = _{ subdivision | alternating | polymeter }

// this should actually be { expr | group | single } at some point
/// parameter for expressions with operators
parameter = _{ single }

// target       = { (ASCII_ALPHANUMERIC | "_")+ }

/// operators
op_replicate = ${ "!" ~ single }
op_weight    = ${ "@" ~ single? }
op_degrade   = ${ "?" ~ single? }
op_target    = ${ ":" ~ single }

op_fast      = ${ "*" ~ parameter }
op_slow      = ${ "/" ~ parameter }
op_bjorklund = { "(" ~ (parameter ~ ",")+ ~ parameter ~ ")" }
single_op = _{op_target | op_degrade | op_replicate | op_weight}
op = _{ op_fast | op_slow | op_bjorklund }

expr        = { (single | group) ~ op+ }
single_expr = { (single | group) ~ single_op+ }
range_expr  = ${ integer ~ ".." ~ integer }

/// helper container that splits steps into sections
section   = { (single_expr | expr | range_expr | single | repeat | group)+ }

/// a single choice inside a choice list
choice    = { single_expr | expr | range_expr | single | group }
/// at least 2 choices, can only be inside subdivisions or the root
choices   = { (choice) ~ ("|" ~ choice)+ }

/// parallel sections of events found inside groups
stack     = { (section) ~ ("," ~ section)+ }

// shorthand for subdivisions
// split          = { (section) ~ ("." ~ section)+ }

/// the root of the cycle
mini = { SOI ~ ( stack | choices | section) ~ EOI }
